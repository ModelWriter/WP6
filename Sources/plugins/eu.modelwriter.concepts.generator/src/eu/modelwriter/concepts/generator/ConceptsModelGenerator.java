package eu.modelwriter.concepts.generator;

import java.io.File;
import java.io.IOException;
import java.util.Collections;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IWorkspace;
import org.eclipse.core.resources.IWorkspaceRoot;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.core.runtime.Path;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.xmi.impl.XMIResourceFactoryImpl;

import eu.modelwriter.models.concepts.Concept;
import eu.modelwriter.models.concepts.ConceptClass;
import eu.modelwriter.models.concepts.ConceptMethod;
import eu.modelwriter.models.concepts.ConceptParameter;
import eu.modelwriter.models.concepts.ConceptVariable;
import eu.modelwriter.models.concepts.ConceptsFactory;
import eu.modelwriter.models.concepts.ConceptsRoot;
import eu.modelwriter.models.concepts.ContextPackage;
import eu.modelwriter.models.concepts.JavaConceptsContainer;
import eu.modelwriter.models.concepts.Type;
import fr.obeo.ariadne.model.code.Classifier;
import fr.obeo.ariadne.model.code.ClasspathEntry;
import fr.obeo.ariadne.model.code.Component;
import fr.obeo.ariadne.model.code.Field;
import fr.obeo.ariadne.model.code.Operation;
import fr.obeo.ariadne.model.code.Parameter;
import fr.obeo.ariadne.model.code.TypesContainer;
import fr.obeo.ariadne.model.code.VisibilityKind;
import fr.obeo.ariadne.model.continuousintegration.ContinuousintegrationPackage;
import fr.obeo.ariadne.model.organization.Category;
import fr.obeo.ariadne.model.organization.Organization;
import fr.obeo.ariadne.model.organization.OrganizationPackage;
import fr.obeo.ariadne.model.organization.Project;
import fr.obeo.ariadne.model.tasks.TasksPackage;

public class ConceptsModelGenerator {
	private static String MODEL_EXTENSION = "ariadneorganization";

	private IPath outputIPath;
	private IFile inputOrganizationFile;
	private IProject project;
	private ConceptsRoot conceptsRoot;

	private Organization organization;

	/**
	 * Constructor.
	 * 
	 * @param modelRelativePath
	 *            the organization model relative path. (generated by Ariadne)
	 */
	public ConceptsModelGenerator(String modelRelativePath) {
		this.organization = loadOrganizationModel(modelRelativePath);
		IWorkspace workspace = ResourcesPlugin.getWorkspace();
		if (workspace == null) {
			throw new IllegalStateException(
					"no workspace is available or open.");
		}
		IWorkspaceRoot workspaceRoot = workspace.getRoot();
		URI uri = organization.eResource().getURI();
		this.inputOrganizationFile = workspaceRoot.getFile(new Path(uri
				.device(), uri.path()));
		this.project = inputOrganizationFile.getProject();
		this.outputIPath = inputOrganizationFile.getFullPath()
				.removeFileExtension().addFileExtension("concepts");
		this.conceptsRoot = ConceptsFactory.eINSTANCE.createConceptsRoot();
	}

	/**
	 * Generates the Concepts Model basing on the organization file.
	 * 
	 * @return the generated Concepts Model instance.
	 * @throws ConceptsModelGeneratorException
	 */
	public ConceptsRoot generate() throws ConceptsModelGeneratorException {
		if (organization != null) {
			extractInformation();
			attachReferencedClassesToTypes();
			saveOutput();
			return conceptsRoot;
		} else {
			throw new NullPointerException(
					"We are not able to load the Ariadne organization for the given file: "
							+ organization.eResource().getURI().path());
		}
	}

	/**
	 * Loads the organization model.
	 * 
	 * @return the organization.
	 */
	private Organization loadOrganizationModel(String modelRelativePath) {
		EPackage.Registry.INSTANCE.put(OrganizationPackage.eNS_URI,
				OrganizationPackage.eINSTANCE);
		EPackage.Registry.INSTANCE.put(ContinuousintegrationPackage.eNS_URI,
				ContinuousintegrationPackage.eINSTANCE);
		EPackage.Registry.INSTANCE.put(TasksPackage.eNS_URI,
				TasksPackage.eINSTANCE);

		ResourceSet resourceSet = new ResourceSetImpl();
		resourceSet.getResourceFactoryRegistry().getExtensionToFactoryMap()
				.put(MODEL_EXTENSION, new XMIResourceFactoryImpl());

		Resource organizationModelResource = resourceSet.getResource(
				URI.createFileURI(modelRelativePath), true);
		if (organizationModelResource != null
				&& !organizationModelResource.getContents().isEmpty()) {
			EObject rootEObject = organizationModelResource.getContents()
					.get(0);
			if (rootEObject instanceof Organization) {
				EcoreUtil.resolveAll(rootEObject); // Ensure that all resolvable
													// proxies are resolved
				return (Organization) rootEObject;
			}
		}
		return null;
	}

	/**
	 * Extracts all concepts and their contexts.
	 */
	private void extractInformation() {
		for (Category categ : organization.getCategories()) {
			for (Project proj : categ.getProjects()) {
				for (Component comp : proj.getComponents()) {
					JavaConceptsContainer currentJavaPluginConcept = ConceptsFactory.eINSTANCE
							.createJavaConceptsContainer();
					currentJavaPluginConcept.setName(comp.getIdentifier());
					conceptsRoot.getJavaConcepts()
							.add(currentJavaPluginConcept);
					extractPackages(comp, currentJavaPluginConcept);
				}
			}
		}
	}

	/**
	 * Extracts the packages.
	 * 
	 * @param component
	 *            the current component in the organization.
	 * @param currentJavaPluginConcept
	 *            the current Java Plugin container concept.
	 */
	private void extractPackages(Component component,
			JavaConceptsContainer currentJavaPluginConcept) {
		for (ClasspathEntry classPathEntry : component.getClasspathEntries()) {
			ContextPackage currentContextPackage = null;
			for (TypesContainer typesContainer : classPathEntry
					.getTypesContainers()) {
				if (!typesContainer.getTypes().isEmpty()) {
					currentContextPackage = ConceptsFactory.eINSTANCE
							.createContextPackage();
					currentContextPackage.setName(typesContainer.getName());
					currentJavaPluginConcept.getContexts().add(
							currentContextPackage);
				}
				extractClasses(typesContainer, currentContextPackage,
						currentJavaPluginConcept);
			}
		}
	}

	/**
	 * Extracts the Classifiers of a package.
	 * 
	 * @param container
	 *            the classifier container.
	 * @param currentContextPackage
	 *            the current {@link ContextPackage}.
	 */
	private void extractClasses(TypesContainer container,
			ContextPackage currentContextPackage,
			JavaConceptsContainer currentJavaPluginConcept) {
		for (fr.obeo.ariadne.model.code.Type type : container.getTypes()) {
			if (type instanceof Classifier) {
				ConceptClass currentConceptClass = ConceptsFactory.eINSTANCE
						.createConceptClass();
				// currentConceptClass.setName(type.getQualifiedName());
				currentConceptClass.setName(type.getName());
				currentConceptClass.setContext(currentContextPackage);

				currentJavaPluginConcept.getConcepts().add(currentConceptClass);

				extractAttributes((Classifier) type, currentConceptClass,
						currentJavaPluginConcept);
				extractOperations((Classifier) type, currentConceptClass,
						currentJavaPluginConcept);
			}
		}
	}

	/**
	 * Extracts the attributes of a classifier.
	 * 
	 * @param currentClass
	 *            the current classifier.
	 * @param currentConceptClass
	 *            the current {@link ConceptClass}.
	 */
	private void extractAttributes(Classifier currentClass,
			ConceptClass currentConceptClass,
			JavaConceptsContainer currentJavaPluginConcept) {
		for (Field field : currentClass.getFields()) {
			if (VisibilityKind.PUBLIC.equals(field.getVisibility())
					|| VisibilityKind.PROTECTED.equals(field.getVisibility())) {
				ConceptVariable currentVariable = ConceptsFactory.eINSTANCE
						.createConceptVariable();
				currentVariable.setName(field.getName());
				currentVariable.setContext(currentConceptClass);
				currentJavaPluginConcept.getConcepts().add(currentVariable);

				String fieldMinName = minimizeName(field.getQualifiedName(),
						VisibilityKind.PUBLIC.equals(field.getVisibility()),
						VisibilityKind.PROTECTED.equals(field.getVisibility()),
						field.isStatic(), field.isFinal());

				Type type = addType(fieldMinName.replace(field.getName(), "")
						.trim());
				currentVariable.setReturnType(type);
			}
		}
	}

	private void attachReferencedClassesToTypes() {
		for (JavaConceptsContainer jConcept : conceptsRoot.getJavaConcepts()) {
			for (Concept concept : jConcept.getConcepts()) {
				for (Type type : conceptsRoot.getTypes()) {
					if (concept instanceof ConceptClass) {
						if (concept.getName().equals(type.getName())) {
							type.getReferencedClass().add(
									(ConceptClass) concept);
						} else if (type.getName() != null
								&& (type.getName().contains(
										"<" + concept.getName() + ">")
										|| type.getName().contains(
												"<" + concept.getName() + ",")
										|| type.getName().contains(
												"," + concept.getName() + ">") || type
										.getName().contains(
												"," + concept.getName() + ","))) {
							type.getReferencedClass().add(
									(ConceptClass) concept);
						}
					}
				}
			}
		}
	}

	/**
	 * Returns the type which have the given name. It Creates a new type if it
	 * does not exists.
	 * 
	 * @param returnTypeName
	 *            the given name.
	 * @return the type which have the given name. It Creates a new type if it
	 *         does not exists.
	 */
	private Type addType(String returnTypeName) {
		for (Type type : conceptsRoot.getTypes()) {
			if (type.getName().equals(returnTypeName)) {
				return type;
			}
		}
		Type type = ConceptsFactory.eINSTANCE.createType();
		type.setName(returnTypeName);
		conceptsRoot.getTypes().add(type);
		return type;
	}

	/**
	 * Extracts the operations of a classifier.
	 * 
	 * @param currentClass
	 *            the current classifier.
	 * @param currentConceptClass
	 *            the current {@link ConceptClass}.
	 */
	private void extractOperations(Classifier currentClass,
			ConceptClass currentConceptClass,
			JavaConceptsContainer currentJavaPluginConcept) {
		for (Operation operation : currentClass.getOperations()) {
			if (VisibilityKind.PUBLIC.equals(operation.getVisibility())
					|| VisibilityKind.PROTECTED.equals(operation
							.getVisibility())) {

				ConceptMethod currentMethod = ConceptsFactory.eINSTANCE
						.createConceptMethod();
				currentMethod.setName(operation.getName());

				extractParameters(operation, currentMethod,
						currentJavaPluginConcept);

				String operationName = minimizeName(operation
						.getQualifiedName(), VisibilityKind.PUBLIC
						.equals(operation.getVisibility()),
						VisibilityKind.PROTECTED.equals(operation
								.getVisibility()), operation.isStatic(),
						operation.isFinal());
				int index = operationName.indexOf(operation.getName());
				Type type = addType(operationName.substring(0, index).trim());

				currentMethod.setReturnType(type);
				currentMethod.setContext(currentConceptClass);
				currentJavaPluginConcept.getConcepts().add(currentMethod);
			}
		}
	}

	/**
	 * Extracts the parameters of a given operation.
	 * 
	 * @param operation
	 *            the given operation
	 * @param currentMethod
	 *            the current method concept
	 * @param currentJavaPluginConcept
	 *            the java plugin concept.
	 */
	private void extractParameters(Operation operation,
			ConceptMethod currentMethod,
			JavaConceptsContainer currentJavaPluginConcept) {
		for (Parameter param : operation.getParameters()) {
			ConceptParameter conceptParameter = ConceptsFactory.eINSTANCE
					.createConceptParameter();
			conceptParameter.setName(param.getName());

			Type type = addType(param.getQualifiedName()
					.replace(param.getName(), "").trim());
			conceptParameter.setType(type);
			conceptParameter.setContext(currentMethod);

			currentMethod.getParameters().add(conceptParameter);
			currentJavaPluginConcept.getConcepts().add(conceptParameter);
		}
	}

	private String minimizeName(String qualifiedName, boolean isPublic,
			boolean isProtected, boolean isStatic, boolean isFinal) {
		String name = qualifiedName;
		if (isPublic) {
			name = name.substring("public ".length());
		} else if (isProtected) {
			name = name.substring("protected ".length());
		}
		if (isStatic) {
			name = name.substring("static ".length());
		}
		if (isFinal) {
			name = name.substring("final ".length());
		}
		while (name.startsWith(" ")) {
			name = name.substring(1);
		}
		return name;
	}

	/**
	 * Saves the output beside the input organization model.
	 * 
	 * @throws ConceptsModelGeneratorException
	 */
	private void saveOutput() throws ConceptsModelGeneratorException {
		File file = new File(outputIPath.toOSString());
		String fullPath = file.getAbsolutePath();
		URI uri = URI.createFileURI(fullPath);
		Resource resource = Resource.Factory.Registry.INSTANCE.getFactory(uri)
				.createResource(uri);
		resource.getContents().add(conceptsRoot);

		try {
			resource.save(Collections.EMPTY_MAP);
			project.refreshLocal(IResource.DEPTH_INFINITE,
					new NullProgressMonitor());
		} catch (IOException e) {
			throw new ConceptsModelGeneratorException(
					"A problem has occured while saving the output.", e);
		} catch (CoreException e) {
			throw new ConceptsModelGeneratorException(
					"A problem has occured while refreshing the project.", e);
		}
	}
}
